First create the package.json file with command ---> npm init
To run the node file, we have to write ---> node fileName

Gloabl Object---- window, global
    In Browser we have window is global Object. The window object is given by Browser not by the V8 Engine.
    But in node we have global as a global object. Global is given by Node.js not by V8 Engine.
   
    Behaviour of this : 
    CommonJS: Top-level this is {} (an alias for module.exports). type: "CommonJS"
    ESM: Top-level this is undefined. type: "module"
    How to Fix or Adjust Behavior
    If you want to log this as {} instead of undefined:

    Ensure you're using CommonJS modules:

    Rename your file to .cjs.
    Or, ensure "type": "commonjs" is set in your package.json.
    If you're using ESM (or "type": "module"), this will be undefined by design.

NOTE: In Browser ---> window, this, self, frames --> returns window object
        There are different global object in browser and node 
        so the OpenJS foundation decided to make single gloabl object so that every broswer and node
        can use the global object. 
        And the name of the global object is --> globalThis

Module Exports:
Firstly the require or import file will run and then the other file will execute.
The files are called as module when we are importing into in other module.
Modules protect thier varibales and function from leaking by default. 

CommonJS Modules (cjs)
   - module.exports is used for exporting the modules.
   - require() function is used for importing the modules.
   - by default used by Node.js
   - It is the older way of importing and exporting the modules
   - It is synchronus (means it will fetch imported file and execute the imported file first then it will exexcute the oter file code)
   - It executes the code in non-strict mode.
   - In commonjs module this keyword refers to the empty object

ES Modules (ESM) mjs
   - import statement is used for importing the modules
   - export statement is used for exporting the modules
   - by default used by React.js, Angular.js
   - It is the latest way of importing and exporting the modules
   - It is asynchronous.
   - It executes the code in strict mode.
   - In ES modules this keyword refers to the undefined.

module.exports returns empty object

Behind the scene of require("./filepath)
NOTE: All the code of the module is wrapped inside a function(). And this function is IIFE.
The module is not directly passed to V8 Engine. Firstly is wrapped inside IIFE then it is passed to the V8 Engine.

In IIFE (Immmedialtly Invoked Function Expression)
    
      (function (module, require){
         // module code
      })()

IIFE has two paramters---> module and require.

How require() Works Behind the Scenes ?

There are 5 steps of require() function.

   1. Resolving the Module
      Node.js first determines the path of the module. It checks whether the 
      path is a local file (./local ), a JSON file (.json ), or a module from the node_modules directory, among other possibilities.

   2. Loading the Module
      Once the path is resolved, Node.js loads the file content based on its type. 
      The loading process varies depending on whether the file is JavaScript, JSON, or another type.

   3. Wrapping Inside an IIFE
      The module code is wrapped in an Immediately Invoked Function 
      Expression (IIFE). This wrapping helps encapsulate the module's scope, 
      keeping variables and functions private to the module.

   4. Code Evaluation and Module Exports
      After wrapping, Node.js evaluates the module ºs code. During this evaluation, module.exports is set to export the module's functionality or data. This step essentially makes the module's exports available to other files.

   5. Caching(very imp)
      Importance: Caching is crucial for performance. Node.js caches the result 
      of the require() call so that the module is only loaded and executed once.



NOTE: Calll Stack is single threaded main thread