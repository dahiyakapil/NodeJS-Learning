First create the package.json file with command ---> npm init
To run the node file, we have to write ---> node fileName

Gloabl Object---- window, global
    In Browser we have window is global Object. The window object is given by Browser not by the V8 Engine.
    But in node we have global as a global object. Global is given by Node.js not by V8 Engine.
   
    Behaviour of this : 
    CommonJS: Top-level this is {} (an alias for module.exports). type: "CommonJS"
    ESM: Top-level this is undefined. type: "module"
    How to Fix or Adjust Behavior
    If you want to log this as {} instead of undefined:

    Ensure you're using CommonJS modules:

    Rename your file to .cjs.
    Or, ensure "type": "commonjs" is set in your package.json.
    If you're using ESM (or "type": "module"), this will be undefined by design.

NOTE: In Browser ---> window, this, self, frames --> returns window object
        There are different global object in browser and node 
        so the OpenJS foundation decided to make single gloabl object so that every broswer and node
        can use the global object. 
        And the name of the global object is --> globalThis

Module Exports:
Firstly the require or import file will run and then the other file will execute.
The files are called as module when we are importing into in other module.
Modules protect thier varibales and function from leaking by default. 

CommonJS Modules (cjs)
   - module.exports is used for exporting the modules.
   - require() function is used for importing the modules.
   - by default used by Node.js
   - It is the older way of importing and exporting the modules
   - It is synchronus (means it will fetch imported file and execute the imported file first then it will exexcute the oter file code)
   - It executes the code in non-strict mode.
   - In commonjs module this keyword refers to the empty object

ES Modules (ESM) mjs
   - import statement is used for importing the modules
   - export statement is used for exporting the modules
   - by default used by React.js, Angular.js
   - It is the latest way of importing and exporting the modules
   - It is asynchronous.
   - It executes the code in strict mode.
   - In ES modules this keyword refers to the undefined.

module.exports returns empty object

Behind the scene of require("./filepath)
NOTE: All the code of the module is wrapped inside a function(). And this function is IIFE.
The module is not directly passed to V8 Engine. Firstly is wrapped inside IIFE then it is passed to the V8 Engine.

In IIFE (Immmedialtly Invoked Function Expression)
    
      (function (module, require){
         // module code
      })()

IIFE has two paramters---> module and require.

How require() Works Behind the Scenes ?

There are 5 steps of require() function.

   1. Resolving the Module
      Node.js first determines the path of the module. It checks whether the 
      path is a local file (./local ), a JSON file (.json ), or a module from the node_modules directory, among other possibilities.

   2. Loading the Module
      Once the path is resolved, Node.js loads the file content based on its type. 
      The loading process varies depending on whether the file is JavaScript, JSON, or another type.

   3. Wrapping Inside an IIFE
      The module code is wrapped in an Immediately Invoked Function 
      Expression (IIFE). This wrapping helps encapsulate the module's scope, 
      keeping variables and functions private to the module.

   4. Code Evaluation and Module Exports
      After wrapping, Node.js evaluates the moduleÊ¼s code. During this evaluation, module.exports is set to export the module's functionality or data. This step essentially makes the module's exports available to other files.

   5. Caching(very imp)
      Importance: Caching is crucial for performance. Node.js caches the result 
      of the require() call so that the module is only loaded and executed once.



NOTE: Call Stack is single threaded, main thread




Deep Dive into JSV8 Engine

When you write some piece of code, this code is given to V8 engine.
There are several steps when you give the code to V8 engine.

Steps:
A. Parsing:
   1. Lexical Analysis(Tokenization): In lexical analysis, the code you have given is broken down into Tokens(lexical tokens)
   For example: var a = 10;
   Tokens will be : var, a, =, 10
   V8 Engine read the code token by token.

   2. Syntax Analysis: The code is broekn down into tokens.
      A abstract syntax tree(AST ) is developed.
      Token is converted into AST.
      Website: astexplorer.net

   What is syntax Error?
   When JS V8 Engine is unable to generate the Abstract Syntax Tree(AST). 

B. Interpreter: 

There are two types of languages: 

Intrepreted:
- The code is executed line by line.
- Fast initial execution.
- For execute the code, interpreter is there.




Compiled:
- When we give the code, the whole code is compiled into machine code. (High level code --> Machine code)
- Initially Heavy, but executed fast.
- For execute the code, compiler is there.


AST --> Ignition Interprter + Turbofan Compiler --> Byte Code --> Execution 

When a sum funtion is calling again and again in a program then the Ignition interpreter sees that this sum function can be optimized so Ignition interpreter gives this HOT CODE (sum(1, 2) function) to Turbofan Compiler and then Turbofan compiler converts this sum function into optimized Machine Code. And then the execution happens.

There is deoptimized Code also, means when Turbofan compiler sees that the sum function takes the argument in integers or Numbers then it will convert the code into the optimized machine code but When the Turbofan Compiler sees that arguments passed in sum function are string not integers or number then it deoptimzed the code. And the deoptimzed the code is again sent to the Ignition Interpreter.



 